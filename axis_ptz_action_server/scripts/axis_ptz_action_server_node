#!/usr/bin/env python3

import rospy
import actionlib

from axis_msgs.msg import Ptz
from ptz_action_server_msgs.msg import PtzAction, PtzFeedback, PtzActionGoal, PtzResult
from ptz_action_server_msgs.msg import PtzState
from sensor_msgs.msg import JointState
from threading import Lock, Thread

from math import pi
from math import degrees as rad2deg
from math import radians as deg2rad

def state_callback(data, node):
    node.state_callback(data)

def linear_rescale(x, old_min, old_max, new_min, new_max):
    return (x-old_min) / (old_max - old_min) * (new_max - new_min) + new_min

def clamp(x, min, max, metavar):
    if x < min:
        rospy.logwarn(f'Requested {metavar}={x} is too small. Clamping to {min}')
        return min
    elif x > max:
        rospy.logwarn(f'Requested {metavar}={x} is too large. Clamping to {max}')
        return max
    else:
        return x

class AxisPtzControlNode:
    """Provides a PTZ.action compatible interface for sending pan-tilt-zoom positions to the axis_camera driver
    """

    ## How long before we consider the last message sent on the status topic to be stale?
    STATE_TIMEOUT = rospy.Duration(10)

    def __init__(self):
        self.cmd_ns = rospy.get_param('~cmd_ns', '/axis/cmd')
        if self.cmd_ns[0] != '/':
            self.cmd_ns = f"/{self.cmd_ns}"
        self.cmd_pos_topic = f'{self.cmd_ns}/position'
        self.cmd_vel_topic = f'{self.cmd_ns}/velocity'
        self.status_topic = rospy.get_param('~status_topic', '/axis/state/position')
        self.act_ns = rospy.get_param('~act_ns', '/axis')
        self.invert_tilt = rospy.get_param('~invert_tilt', False)
        self.invert_pan = rospy.get_param('~invert_pan', False)

        self.min_pan = rospy.get_param("~min_pan", deg2rad(-170))
        self.max_pan = rospy.get_param("~max_pan", deg2rad(170))
        self.min_tilt = rospy.get_param("~min_tilt", 0)
        self.max_tilt = rospy.get_param("~max_tilt", deg2rad(90))
        self.min_hw_zoom = rospy.get_param("~min_zoom", 1)
        self.max_hw_zoom = rospy.get_param("~max_zoom", 9999)

        self.publish_joint_states = rospy.get_param("~publish_joint_states", True)
        self.pan_joint = rospy.get_param("~pan_joint", "pan_joint")
        self.tilt_joint = rospy.get_param("~tilt_joint", "tilt_joint")

        self.min_logical_zoom = rospy.get_param("~min_logical_zoom", 1)
        self.max_logical_zoom = rospy.get_param("~max_logical_zoom", 24)

        # allow 1 degree of error when tracking the position feedback
        # this is a little coarse, but the camera isn't a high-precision piece of kit anyway
        self.position_tolerance = deg2rad(1.0)

        # allow some tolerance in the zoom. This is a big range
        self.zoom_tolerance = 10.0

        self.goal_pan = 0.0
        self.goal_tilt = 0.0
        self.goal_zoom = 1.0

        # the camera's current state as reported by the underlying driver
        # initially None so we don't accidentally overwrite e.g. focus or brightness
        self.last_axis_state = None

        # The current logical PTZ state
        self.ptz_state = PtzState()
        self.ptz_state.zoom = 1

        # is the camera currently moving?
        self.is_moving = False
        self.is_moving_lock = Lock()

        self.ptz_abs_srv = actionlib.SimpleActionServer(f'{self.act_ns}/move_ptz/position_abs', PtzAction, self.ptz_abs_actionHandler, False)
        self.ptz_rel_srv = actionlib.SimpleActionServer(f'{self.act_ns}/move_ptz/position_rel', PtzAction, self.ptz_rel_actionHandler, False)
        self.vel_srv = actionlib.SimpleActionServer(f'{self.act_ns}/move_ptz/velocity', PtzAction, self.vel_actionHandler, False)

        self.last_state_at = rospy.Time.now()
        self.last_command_at = rospy.Time.now()

    def start(self):
        """Starts the subscribers, publishers, and service handlers
        """
        self.cmd_pos_pub = rospy.Publisher(self.cmd_pos_topic, Ptz, queue_size=1)
        self.cmd_vel_pub = rospy.Publisher(self.cmd_vel_topic, Ptz, queue_size=1)
        self.status_sub = rospy.Subscriber(self.status_topic, Ptz, self.state_callback)
        self.status_pub = rospy.Publisher(f'{self.act_ns}/ptz_state', PtzState, queue_size=1)

        if self.publish_joint_states:
            self.joint_state_pub = rospy.Publisher("/joint_states", JointState, queue_size=1)
            self.js_thread = Thread(target=self.joint_state_pub_thread)
            self.js_thread.start()

        self.ptz_abs_srv.start()
        self.ptz_rel_srv.start()
        self.vel_srv.start()

    def state_callback(self, data):
        """Monitors the position of the camera to determine if the pan and tilt joints have reached their
        goal positions yet

        Also saves the current state to self.last_axis_state

        @param data  The Ptz.msg information received on the topic
        """
        pan = deg2rad(data.pan)
        tilt = deg2rad(data.tilt)
        zoom = linear_rescale(data.zoom, self.min_hw_zoom, self.max_hw_zoom, self.min_logical_zoom, self.max_logical_zoom)

        # invert pan & tilt if necessary
        if self.invert_tilt:
            tilt = -tilt
        if self.invert_pan:
            pan = -pan

        # distance remaining to goal state
        pan_remaining = abs(pan - self.goal_pan)
        tilt_remaining = abs(tilt - self.goal_tilt)
        zoom_remaining = abs(zoom - self.goal_zoom)

        # delta between now and the previous reading
        dpan = abs(pan - self.ptz_state.pan)
        dtilt = abs(tilt - self.ptz_state.tilt)
        dzoom = abs(zoom - self.ptz_state.zoom)

        # assume we've stopped if the pan and tilt speeds are both less that 0.1 deg/s
        # there aren't many use-cases where movement that slow would be necessary
        POINT_ONE_DEGREE = deg2rad(0.1)

        if self.is_moving:
            if self.ptz_state.mode == PtzState.MODE_POSITION:
                # check if we've reached the goal
                if dpan <= self.position_tolerance and dtilt <= self.position_tolerance and dzoom <= self.zoom_tolerance:
                    rospy.loginfo("PTZ reached goal!")
                    self.is_moving = False
            elif self.ptz_state.mode == PtzState.MODE_VELOCITY:
                if dpan == 0 and dtilt == 0 and dzoom == 0:
                    rospy.loginfo("PTZ reached end-of-travel!")
                    self.is_moving = False

        self.last_axis_state = data
        self.last_state_at = rospy.Time.now()

        # publish the current PTZ state
        self.ptz_state.pan = pan
        self.ptz_state.tilt = tilt
        self.ptz_state.zoom = zoom
        self.status_pub.publish(self.ptz_state)

    def joint_state_pub_thread(self):
        js = JointState()

        rate = rospy.Rate(10)
        while not rospy.is_shutdown():
            js.header.stamp = rospy.Time.now()
            js.name = [self.pan_joint, self.tilt_joint]
            js.position = [self.ptz_state.pan, self.ptz_state.tilt]
            js.velocity = [0, 0]
            js.effort = [0, 0]
            self.joint_state_pub.publish(js)
            rate.sleep()

    def ptz_abs_actionHandler(self, ptz_req):
        """Handles PTZ.action requests to set absolute pan/tilt/zoom positions

        Converts the PTZ goal into an Axis.msg we write to the axis_camera driver
        and then wait until the feedback topic reports that the PTU has finished moving

        @param ptz_req  The PtzGoal object to process
        """
        if self.last_axis_state == None:
            # We have never contacted the camera; block until we hear _something_
            rospy.logwarn('Still waiting for initial state from the camera. Cannot move yet')
            ptz_resp = PtzResult()
            ptz_resp.success = False
            self.ptz_abs_srv.set_aborted(ptz_resp, 'Still waiting for initial state from the camera. Cannot move yet')

        elif rospy.Time.now() - self.last_state_at > self.STATE_TIMEOUT:
            # We haven't heard from the camera in a while; block until the camera updates its status again
            rospy.logwarn("Status of Axis camera is stale. Waiting for the camera to come back online")
            ptz_resp = PtzResult()
            ptz_resp.success = False
            self.ptz_abs_srv.set_aborted(ptz_resp, "Status of Axis camera is stale; waiting for camera to publish its state again")

        else:
            if self.ptz_state.mode == PtzState.MODE_VELOCITY:
                self.vel_srv.set_aborted("Asserting position control")

            # The camera is alive and ready to move
            self.goal_pan = clamp(ptz_req.pan, self.min_pan, self.max_pan, 'pan')
            self.goal_tilt = clamp(ptz_req.tilt, self.min_tilt, self.max_tilt, 'tilt')
            self.goal_zoom = clamp(ptz_req.zoom, self.min_logical_zoom, self.max_logical_zoom, 'zoom')

            # send the command to the camera
            self.is_moving = True
            cmd = Ptz()
            ptz.pan = self.goal_pan
            ptz.tilt = self.goal_tilt
            ptz.zoom = self.goal_zoom
            self.cmd_vel_pub.publish(cmd)
            self.last_command_at = rospy.Time.now()
            self.ptz_state.mode = PtzState.MODE_POSITION

            # sleep until joint_states reports that the pan and tilt joints have reached the desired position OR
            # have stopped moving
            rate = rospy.Rate(2)
            timed_out = False
            while self.is_moving and not self.ptz_abs_srv.is_preempt_requested() and not timed_out:
                feedback = PtzFeedback()
                feedback.zoom_remaining = self.goal_zoom - self.ptz_state.zoom
                feedback.pan_remaining = self.goal_pan - self.ptz_state.pan
                feedback.tilt_remaining = self.goal_tilt - self.ptz_state.tilt
                self.ptz_srv.publish_feedback(feedback)

                if rospy.Time.now() - self.last_state_at > self.STATE_TIMEOUT:
                    timed_out = True
                else:
                    rospy.logdebug(f"PTZ is still moving ({feedback.pan_remaining}, {feedback.tilt_remaining}, {feedback.zoom_remaining}) to go")
                    rate.sleep()

            if self.ptz_abs_srv.is_preempt_requested():
                rospy.logwarn("PTZ action preempted")
                self.is_moving = False
                self.ptz_abs_srv.set_preempted()
            elif timed_out:
                rospy.logwarn("Timed out waiting for axis camera state")
                self.is_moving = False
                ptz_resp = PtzResult()
                ptz_resp.success = False
                self.ptz_state.mode = PtzState.MODE_IDLE
                self.ptz_abs_srv.set_aborted(ptz_resp, "Timed out waiting for axis camera state; did the camera go offline?")
            else:
                rospy.logdebug("PTZ action completed successfully")
                ptz_resp = PtzResult()
                ptz_resp.success = True
                self.ptz_state.mode = PtzState.MODE_IDLE
                self.ptz_abs_srv.set_succeeded(ptz_resp)

    def ptz_rel_actionHandler(self, ptz_req):
        """Handler for moving the camera to a relative pan/tilt/zoom from current

        Converts the relative pan/tilt/zoom to absolute positions and uses the position_abs action
        """
        abs_goal = PtzGoal(self.current_pan + ptz_req.pan,
                           self.current_tilt + ptz_req.tilt,
                           self.current_zoom + ptz_req.zoom
        )

        ptz_client = actionlib.SimpleActionClient("move_ptz/position_abs", PtzAction)
        ptz_client.wait_for_server()

        def done_cb(state, result):
            if state == actionlib.GoalStatus.SUCCEEDED:
                self.ptz_rel_srv.set_succeeded(result)
            elif state == actionlib.GoalStatus.PREEMPTED:
                self.ptz_rel_srv.set_preempted()
            else:
                self.ptz_rel_srv.set_aborted(result)

        ptz_client.send_goal(abs_goal,
            feedback_cb = lambda fb: self.ptz_rel_srv.publish_feedback(fb),
            done_cb = done_cb
        )
        ptz_client.wait_for_result()

    def vel_actionHandler(self, ptz_req):
        """Handles PTZ.action requests for velocity control

        Converts the PTZ goal into an Axis.msg we write to the axis_camera driver
        and then wait until the feedback topic reports that the PTU has finished moving

        @param ptz_req  The PtzGoal object to process
        """
        if self.last_axis_state == None:
            # We have never contacted the camera; block until we hear _something_
            rospy.logwarn('Still waiting for initial state from the camera. Cannot move yet')
            ptz_resp = PtzResult()
            ptz_resp.success = False
            self.vel_srv.set_aborted(ptz_resp, 'Still waiting for initial state from the camera. Cannot move yet')
        elif rospy.Time.now() - self.last_state_at > self.STATE_TIMEOUT:
            # We haven't heard from the camera in a while; block until the camera updates its status again
            rospy.logwarn("Status of Axis camera is stale. Waiting for the camera to come back online")
            ptz_resp = PtzResult()
            ptz_resp.success = False
            self.vel_srv.set_aborted(ptz_resp, "Status of Axis camera is stale; waiting for camera to publish its state again")
        elif self.ptz_state.mode == PtzState.MODE_POSITION:
            # We're processiung a position command; it must finish first
            rospy.logwarn("Camera is moving under position control. Wait for that action to finish before using velocityu control")
            ptz_resp = PtzResult()
            ptz_resp.success = False
            self.vel_srv.set_aborted(ptz_resp, "Camera is moving under position control")
        elif self.ptz_state.mode == PtzState.MODE_VELOCITY and ptz_req.pan == 0 and ptz_req.tilt == 0 and ptz_req.zoom == 0:
            rospy.loginfo("Stopping camera")
            self.vel_srv.set_preempted()
        else:
            # The camera is alive and ready to move
            cmd = Ptz()
            cmd.pan = ptz_req.pan
            cmd.tilt = ptz_req.tilt
            cmd.zoom = ptz_req.zoom
            self.cmd_vel_pub.publish(cmd)
            if cmd.pan != 0 or cmd.tilt != 0 or cmd.zoom != 0:
                self.is_moving = True
                self.ptz_state.mode = PtzState.MODE_VELOCITY

                rate = rospy.Rate(2)
                timed_out = False
                while self.is_moving and not self.vel_srv.is_preempt_requested() and not timed_out:
                    feedback = PtzFeedback()
                    feedback.zoom_remaining = math.copysign(1, req.zoom)
                    feedback.pan_remaining = math.copysign(1, req.pan)
                    feedback.tilt_remaining = math.copysign(1, req.tilt)
                    self.vel_srv.publish_feedback(feedback)

                    if rospy.Time.now() - self.last_state_at > self.STATE_TIMEOUT:
                        timed_out = True
                    else:
                        rospy.logdebug(f"PTZ is still moving ({feedback.pan_remaining}, {feedback.tilt_remaining}, {feedback.zoom_remaining}) to go")
                        rate.sleep()

                if self.vel_srv.is_preempt_requested():
                    rospy.logwarn("Velocity action preempted")
                    self.is_moving = False
                    self.vel_srv.set_preempted()
                elif timed_out:
                    rospy.logwarn("Timed out waiting for axis camera state")
                    self.is_moving = False
                    ptz_resp = PtzResult()
                    ptz_resp.success = False
                    self.vel_state = PtzState.MODE_IDLE
                    self.vel_srv.set_aborted(ptz_resp, "Timed out waiting for axis camera state; did the camera go offline?")
                else:
                    rospy.logdebug("Velocity action completed successfully")
                    ptz_resp = PtzResult()
                    ptz_resp.success = True
                    self.ptz_state.mode = PtzState.MODE_IDLE
                    self.vel_srv.set_succeeded(ptz_resp)
            else:
                rospy.logdebug("Velocity action completed successfully")
                ptz_resp = PtzResult()
                ptz_resp.success = True
                self.is_moving = False
                self.ptz_state.mode = PtzState.MODE_IDLE
                self.vel_srv.set_succeeded(ptz_resp)


def main():
    rospy.init_node('axis_ptz_action_server_node', anonymous=True)
    node = AxisPtzControlNode()
    node.start()
    rospy.spin()

if __name__=='__main__':
    main()
