#!/usr/bin/env python3

import rclpy
from rclpy.action import ActionServer, ActionClient, CancelResponse
from rclpy.callback_groups import ReentrantCallbackGroup
from rclpy.executors import MultiThreadedExecutor
from rclpy.node import Node

import math
import tf2_ros
import tf2_geometry_msgs
import tf.transformations
import threading
import uuid

from action_msgs.msg import GoalStatus
from axis_msgs.msg import Ptz
from geometry_msgs.msg import TransformStamped
from ptz_action_server_msgs.action import PtzMove, PtzFrame, PtzRelTo
from ptz_action_server_msgs.msg import PtzState
from sensor_msgs.msg import JointState
from threading import Lock, Thread

from math import pi
from math import degrees as rad2deg
from math import radians as deg2rad


class AxisPtzControlNode(Node):
    """Provides a PTZ.action compatible interface for sending pan-tilt-zoom positions to the axis_camera driver
    """

    ## How long before we consider the last message sent on the status topic to be stale?
    STATE_TIMEOUT = rclpy.duration.Duration(10)

    def __init__(self, name):
        super().__init__(name)
        self.cmd_ns = self.declare_parameter('~cmd_ns', '/axis/cmd').value
        if self.cmd_ns[0] != '/':
            self.cmd_ns = f"/{self.cmd_ns}"
        self.cmd_pos_topic = f'{self.cmd_ns}/position'
        self.cmd_vel_topic = f'{self.cmd_ns}/velocity'
        self.status_topic = self.declare_parameter('~status_topic', '/axis/state/position').value
        self.act_ns = self.declare_parameter('~act_ns', '/axis').value
        self.invert_tilt = self.declare_parameter('~invert_tilt', False).value
        self.invert_pan = self.declare_parameter('~invert_pan', False).value

        self.min_pan = self.declare_parameter("~min_pan", deg2rad(-170)).value
        self.max_pan = self.declare_parameter("~max_pan", deg2rad(170)).value
        self.min_tilt = self.declare_parameter("~min_tilt", 0).value
        self.max_tilt = self.declare_parameter("~max_tilt", deg2rad(90)).value
        self.min_hw_zoom = self.declare_parameter("~min_zoom", 1).value
        self.max_hw_zoom = self.declare_parameter("~max_zoom", 9999).value

        self.camera_base_link = self.declare_parameter("~camera_base_link", "base_link").value

        self.publish_joint_states = self.declare_parameter("~publish_joint_states", True).value
        self.pan_joint = self.declare_parameter("~pan_joint", "pan_joint").value
        self.tilt_joint = self.declare_parameter("~tilt_joint", "tilt_joint").value

        self.min_logical_zoom = self.declare_parameter("~min_logical_zoom", 1).value
        self.max_logical_zoom = self.declare_parameter("~max_logical_zoom", 24).value

        # allow 1 degree of error when tracking the position feedback
        # this is a little coarse, but the camera isn't a high-precision piece of kit anyway
        self.position_tolerance = deg2rad(1.0)

        # allow some tolerance in the zoom. This is a big range
        self.zoom_tolerance = 10.0

        self.goal_pan = 0.0
        self.goal_tilt = 0.0
        self.goal_zoom = 1.0

        # the camera's current state as reported by the underlying driver
        # initially None so we don't accidentally overwrite e.g. focus or brightness
        self.last_axis_state = None

        # The current logical PTZ state
        self.ptz_state = PtzState()
        self.ptz_state.pan = 0
        self.ptz_state.tilt = 0
        self.ptz_state.zoom = 1

        # is the camera currently moving?
        self.is_moving = False
        self.is_moving_lock = Lock()

        # Action Servers

        self._goal_handle = None
        self._goal_lock = threading.Lock()
        self.ptz_abs_action = ActionServer(
            self,
            PtzMove,
            f'{self.act_ns}/move_ptz/position_abs',
            execute_callback=self.ptz_abs_actionHandler,
            callback_group=ReentrantCallbackGroup(),
            cancel_callback=self.cancel_callback,
            handle_accepted_callback=self.handle_accepted_callback)
        self.ptz_rel_action = ActionServer(
            self,
            PtzMove,
            f'{self.act_ns}/move_ptz/position_rel',
            execute_callback=self.ptz_rel_actionHandler,
            callback_group=ReentrantCallbackGroup(),
            cancel_callback=self.cancel_callback,
            handle_accepted_callback=self.handle_accepted_callback)
        self.vel_action = ActionServer(
            self,
            PtzMove,
            f'{self.act_ns}/move_ptz/velocity',
            execute_callback=self.vel_actionHandler,
            callback_group=ReentrantCallbackGroup(),
            cancel_callback=self.cancel_callback,
            handle_accepted_callback=self.handle_accepted_callback)
        self.tf_ptz_abs_action = ActionServer(
            self,
            PtzRelTo,
            f'{self.act_ns}/move_ptz/position_abs_tf',
            execute_callback=self.tf_ptz_abs_actionHandler,
            callback_group=ReentrantCallbackGroup(),
            cancel_callback=self.cancel_callback,
            handle_accepted_callback=self.handle_accepted_callback)
        self.frame_ptz_action = ActionServer(
            self,
            PtzFrame,
            'move_ptz/frame',
            execute_callback=self.frame_ptz_actionHandler,
            callback_group=ReentrantCallbackGroup(),
            cancel_callback=self.cancel_callback,
            handle_accepted_callback=self.handle_accepted_callback)

        self.last_state_at = self.get_clock().now()
        self.last_command_at = self.get_clock().now()

        self.tf_broadcaster = tf2_ros.StaticTransformBroadcaster()
        self.camera_vector_frame = f"camera_vector_frame_{str(uuid.uuid1()).replace('-', '_')}"

        self.start()

    def destroy_node(self):
        self.ptz_abs_action.destroy()
        self.ptz_rel_action.destroy()
        self.vel_action.destroy()
        self.tf_ptz_abs_action.destroy()
        self.frame_ptz_action.destroy()
        super().destroy_node()

    def start(self):
        """Starts the subscribers, publishers, and service handlers
        """
        self.cmd_pos_pub = self.create_publisher(Ptz, self.cmd_pos_topic)
        self.cmd_vel_pub = self.create_publisher(Ptz, self.cmd_vel_topic)
        self.status_sub = self.create_subscription(Ptz, self.state_callback)
        self.status_pub = self.create_publisher(PtzState, f'{self.act_ns}/ptz_state')

        if self.publish_joint_states:
            self.joint_state_pub = self.create_publisher(JointState, "/joint_states")
            self.js_thread = Thread(target=self.joint_state_pub_thread)
            self.js_thread.start()

    def linear_rescale(self, x, old_min, old_max, new_min, new_max):
        return (x-old_min) / (old_max - old_min) * (new_max - new_min) + new_min

    def clamp(self, x, min, max, metavar):
        if x < min:
            self.get_logger().warning(f'Requested {metavar}={x} is too small. Clamping to {min}')
            return min
        elif x > max:
            self.get_logger().warning(f'Requested {metavar}={x} is too large. Clamping to {max}')
            return max
        else:
            return x

    def state_callback(self, data):
        """Monitors the position of the camera to determine if the pan and tilt joints have reached their
        goal positions yet

        Also saves the current state to self.last_axis_state

        @param data  The Ptz.msg information received on the topic
        """
        pan = data.pan
        tilt = data.tilt
        zoom = self.linear_rescale(data.zoom, self.min_hw_zoom, self.max_hw_zoom, self.min_logical_zoom, self.max_logical_zoom)

        # invert pan & tilt if necessary
        if self.invert_tilt:
            tilt = -tilt
        if self.invert_pan:
            pan = -pan

        if self.is_moving:
            if self.ptz_state.mode == PtzState.MODE_POSITION:
                pan_remaining = abs(self.goal_pan - pan)
                tilt_remaining = abs(self.goal_tilt - tilt)
                zoom_remaining = abs(self.goal_zoom - zoom)

                # check if we've reached the goal
                if pan_remaining <= self.position_tolerance and \
                   tilt_remaining <= self.position_tolerance and \
                   zoom_remaining <= self.zoom_tolerance:
                    self.get_logger().info("PTZ reached goal!")
                    self.is_moving = False
            elif self.ptz_state.mode == PtzState.MODE_VELOCITY:
                dpan = self.last_axis_state.pan - data.pan
                dtilt = self.last_axis_state.tilt - data.tilt
                dzoom = self.last_axis_state.zoom - data.zoom

                if dpan == 0 and dtilt == 0 and dzoom == 0:
                    self.get_logger().info("PTZ reached end-of-travel!")
                    self.is_moving = False

        self.last_axis_state = data
        self.last_state_at = self.get_clock().now()

        # publish the current PTZ state
        self.ptz_state.pan = pan
        self.ptz_state.tilt = tilt
        self.ptz_state.zoom = zoom
        self.status_pub.publish(self.ptz_state)

    def joint_state_pub_thread(self):
        js = JointState()

        rate = self.create_rate(10)
        while not rclpy.ok():
            js.header.stamp = self.get_clock().now()
            js.name = [self.pan_joint, self.tilt_joint]
            js.position = [self.ptz_state.pan, self.ptz_state.tilt]
            js.velocity = [0, 0]
            js.effort = [0, 0]
            self.joint_state_pub.publish(js)
            rate.sleep()

    def handle_accepted_callback(self, goal_handle):
        with self._goal_lock:
            # TODO(MIKE): don't we need two goals if we recieve a relative goal??
            # This server only allows one goal at a time
            if self._goal_handle is not None and self._goal_handle.is_active:
                self.get_logger().info('Aborting previous goal')
                # Abort the existing goal
                self._goal_handle.abort()
            self._goal_handle = goal_handle

        goal_handle.execute()

    def cancel_callback(self, goal_handle):
        """Accept or reject a client request to cancel an action."""
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    async def ptz_abs_actionHandler(self, goal_handle):
        """Handles PTZ.action requests to set absolute pan/tilt/zoom positions

        Converts the PTZ goal into an Axis.msg we write to the axis_camera driver
        and then wait until the feedback topic reports that the PTU has finished moving

        @param goal_handle  The PtzGoal object to process
        """
        if self.last_axis_state == None:
            # We have never contacted the camera; block until we hear _something_
            self.get_logger().warning('Still waiting for initial state from the camera. Cannot move yet')
            goal_handle.abort()
            ptz_resp = PtzMove.Result()
            ptz_resp.success = False
            ptz_resp.message = 'Still waiting for initial state from the camera. Cannot move yet'
            return ptz_resp

        elif self.get_clock().now() - self.last_state_at > self.STATE_TIMEOUT:
            # We haven't heard from the camera in a while; block until the camera updates its status again
            self.get_logger().warning("Status of Axis camera is stale. Waiting for the camera to come back online")
            goal_handle.abort()
            ptz_resp = PtzMove.Result()
            ptz_resp.success = False
            ptz_resp.message = "Status of Axis camera is stale. Waiting for the camera to come back online"
            return ptz_resp

        else:
            # The camera is alive and ready to move
            self.goal_pan = self.clamp(goal_handle.pan, self.min_pan, self.max_pan, 'pan')
            self.goal_tilt =self.clamp(goal_handle.tilt, self.min_tilt, self.max_tilt, 'tilt')
            self.goal_zoom = self.clamp(goal_handle.zoom, self.min_logical_zoom, self.max_logical_zoom, 'zoom')

            # send the command to the camera
            self.is_moving = True
            cmd = Ptz()
            cmd.pan = self.goal_pan
            cmd.tilt = self.goal_tilt
            cmd.zoom = self.linear_rescale(self.goal_zoom, self.min_logical_zoom, self.max_logical_zoom, self.min_hw_zoom, self.max_hw_zoom)
            self.cmd_pos_pub.publish(cmd)
            self.last_command_at = self.get_clock().now()
            self.ptz_state.mode = PtzState.MODE_POSITION

            # sleep until joint_states reports that the pan and tilt joints have reached the desired position OR
            # have stopped moving
            rate = self.create_rate(2)
            timed_out = False
            while self.is_moving and not goal_handle.is_cancel_requested and goal_handle.is_active and not timed_out:
                feedback = PtzMove.Feedback()
                feedback.zoom_remaining = self.goal_zoom - self.ptz_state.zoom
                feedback.pan_remaining = self.goal_pan - self.ptz_state.pan
                feedback.tilt_remaining = self.goal_tilt - self.ptz_state.tilt
                goal_handle.publish_feedback(feedback)

                if self.get_clock().now() - self.last_state_at > self.STATE_TIMEOUT:
                    timed_out = True
                else:
                    self.get_logger().debug(f"PTZ is still moving ({feedback.pan_remaining}, {feedback.tilt_remaining}, {feedback.zoom_remaining}) to go")
                    rate.sleep()

            if not goal_handle.is_active:
                self.get_logger().info('PTZ action aborted')
                self.is_moving = False
                return PtzMove.Result()
            if goal_handle.is_cancel_requested:
                goal_handle.canceled()
                self.is_moving = False
                self.get_logger().info('PTZ action canceled')
                return PtzMove.Result()
            elif timed_out:
                self.get_logger().warning("Timed out waiting for axis camera state")
                self.is_moving = False
                ptz_resp = PtzMove.Result()
                ptz_resp.success = False
                ptz_resp.message = "Timed out waiting for axis camera state; did the camera go offline?"
                self.ptz_state.mode = PtzState.MODE_IDLE
                goal_handle.abort()
                return ptz_resp
            else:
                self.get_logger().debug("PTZ action completed successfully")
                ptz_resp = PtzMove.Result()
                ptz_resp.success = True
                self.ptz_state.mode = PtzState.MODE_IDLE
                goal_handle.succeed()
                return ptz_resp

    def ptz_rel_actionHandler(self, goal_handle):
        """Handler for moving the camera to a relative pan/tilt/zoom from current

        Converts the relative pan/tilt/zoom to absolute positions and uses the position_abs action
        """
        abs_goal = PtzMove.Goal(self.ptz_state.pan + goal_handle.pan,
                           self.ptz_state.tilt + goal_handle.tilt,
                           self.ptz_state.zoom + goal_handle.zoom
        )

        ptz_client = ActionClient(self, PtzMove, "move_ptz/position_abs")
        ptz_client.wait_for_server()
        def feedback_cb(feedback):
            self.ptz_rel_srv.publish_feedback(PtzMove.Feedback(feedback.feedback))

        abs_goal_future = ptz_client.send_goal_async(abs_goal,
            feedback_cb = feedback_cb,
        )

        rclpy.spin_until_future_complete(self, abs_goal_future)
        abs_goal_handle = abs_goal_future.result()
        # Check if goal accepted (it always is here)
        get_result_future = abs_goal_handle.get_result_async()

        while not get_result_future.done() and not goal_handle.is_cancel_requested and goal_handle.is_active:
            rclpy.spin_once(self,timeout_sec=1)
        if not goal_handle.is_active:
            self.get_logger().info('PTZ action aborted')
            return PtzMove.Result()
        if goal_handle.is_cancel_requested:
            goal_handle.canceled()
            self.get_logger().info('PTZ action canceled')
            return PtzMove.Result()

        result = get_result_future.result().result
        status = get_result_future.result().status
        if status == GoalStatus.STATUS_SUCCEEDED:
            goal_handle.succeed()
            return result
        elif status == GoalStatus.STATUS_ABORTED:
            goal_handle.abort()
            return result
        else:
            goal_handle.succeed()
            return result

    def vel_actionHandler(self, goal_handle):
        """Handles PTZ.action requests for velocity control

        Converts the PTZ goal into an Axis.msg we write to the axis_camera driver
        and then wait until the feedback topic reports that the PTU has finished moving

        @param goal_handle  The PtzGoal object to process
        """
        if self.last_axis_state == None:
            # We have never contacted the camera; block until we hear _something_
            self.get_logger().warning('Still waiting for initial state from the camera. Cannot move yet')
            ptz_resp = PtzResult()
            ptz_resp.success = False
            self.vel_srv.set_aborted(ptz_resp, 'Still waiting for initial state from the camera. Cannot move yet')
        elif self.get_clock().now() - self.last_state_at > self.STATE_TIMEOUT:
            # We haven't heard from the camera in a while; block until the camera updates its status again
            self.get_logger().warning("Status of Axis camera is stale. Waiting for the camera to come back online")
            ptz_resp = PtzResult()
            ptz_resp.success = False
            self.vel_srv.set_aborted(ptz_resp, "Status of Axis camera is stale; waiting for camera to publish its state again")
        elif self.ptz_state.mode == PtzState.MODE_POSITION:
            # We're processiung a position command; it must finish first
            self.get_logger().warning("Camera is moving under position control. Wait for that action to finish before using velocityu control")
            ptz_resp = PtzResult()
            ptz_resp.success = False
            self.vel_srv.set_aborted(ptz_resp, "Camera is moving under position control")
        elif self.ptz_state.mode == PtzState.MODE_VELOCITY and goal_handle.pan == 0 and goal_handle.tilt == 0 and goal_handle.zoom == 0:
            self.get_logger().info("Stopping camera")
            self.vel_srv.set_preempted()
        else:
            # The camera is alive and ready to move
            cmd = Ptz()
            cmd.pan = goal_handle.pan
            cmd.tilt = goal_handle.tilt
            cmd.zoom = goal_handle.zoom
            self.cmd_vel_pub.publish(cmd)
            if cmd.pan != 0 or cmd.tilt != 0 or cmd.zoom != 0:
                self.is_moving = True
                self.ptz_state.mode = PtzState.MODE_VELOCITY

                rate = self.create_rate(2)
                timed_out = False
                while self.is_moving and not self.vel_srv.is_preempt_requested() and not timed_out:
                    feedback = PtzFeedback()
                    feedback.zoom_remaining = math.copysign(1, goal_handle.zoom)
                    feedback.pan_remaining = math.copysign(1, goal_handle.pan)
                    feedback.tilt_remaining = math.copysign(1, goal_handle.tilt)
                    self.vel_srv.publish_feedback(feedback)

                    if self.get_clock().now() - self.last_state_at > self.STATE_TIMEOUT:
                        timed_out = True
                    else:
                        self.get_logger().debug(f"PTZ is still moving ({feedback.pan_remaining}, {feedback.tilt_remaining}, {feedback.zoom_remaining}) to go")
                        rate.sleep()

                if self.vel_srv.is_preempt_requested():
                    self.get_logger().warning("Velocity action preempted")
                    self.is_moving = False
                    self.vel_srv.set_preempted()
                elif timed_out:
                    self.get_logger().warning("Timed out waiting for axis camera state")
                    self.is_moving = False
                    ptz_resp = PtzResult()
                    ptz_resp.success = False
                    self.vel_state = PtzState.MODE_IDLE
                    self.vel_srv.set_aborted(ptz_resp, "Timed out waiting for axis camera state; did the camera go offline?")
                else:
                    self.get_logger().debug("Velocity action completed successfully")
                    ptz_resp = PtzResult()
                    ptz_resp.success = True
                    self.ptz_state.mode = PtzState.MODE_IDLE
                    self.vel_srv.set_succeeded(ptz_resp)
            else:
                self.get_logger().debug("Velocity action completed successfully")
                ptz_resp = PtzResult()
                ptz_resp.success = True
                self.is_moving = False
                self.ptz_state.mode = PtzState.MODE_IDLE
                self.vel_srv.set_succeeded(ptz_resp)

    def tf_ptz_abs_actionHandler(self, goal_handle):
        """Handler for a TF-aware absolute PTZ action

        We calculate the TF between the camera's base link & the link provided in the request, and then use
        the normal absolute PTZ action internally to move the camera to the corresponding position
        """
        # calculate the initial absolute goal as if there is no TF to apply
        abs_goal = PtzGoal(goal_handle.pan,
                           goal_handle.tilt,
                           goal_handle.zoom
        )

        if goal_handle.frame_id:
            try:
                # add a temporary frame to represent the desired camera vector
                camera_vector_q = tf.transformations.quaternion_from_euler(0, -goal_handle.tilt, goal_handle.pan)
                static_tf = TransformStamped()
                static_tf.header.stamp = self.get_clock().now()
                static_tf.header.frame_id = goal_handle.frame_id
                static_tf.child_frame_id = self.camera_vector_frame
                static_tf.transform.rotation.x = camera_vector_q[0]
                static_tf.transform.rotation.y = camera_vector_q[1]
                static_tf.transform.rotation.z = camera_vector_q[2]
                static_tf.transform.rotation.w = camera_vector_q[3]
                self.tf_broadcaster.sendTransform(static_tf)

                # The the RPY transformation between the camera base link & the reference frame
                tf_buffer = tf2_ros.Buffer(rclpy.duration.Duration(100.0))
                tf_listener = tf2_ros.TransformListener(tf_buffer)
                tf_stamped = tf_buffer.lookup_transform(self.camera_base_link, self.camera_vector_frame, rclpy.time.Time(), rclpy.duration.Duration(5.0))
                q = tf_stamped.transform.rotation
                (roll, pitch, yaw) = tf.transformations.euler_from_quaternion([q.x, q.y, q.z, q.w])

                # yaw & pitch are right-handed, but pan & tilt are left-handed, so invert them
                abs_goal.pan = -yaw
                abs_goal.tilt = -pitch

                # clamp the adjusted pan to lie within [-pi, pi]
                while abs_goal.pan < -math.pi:
                    abs_goal.pan += math.pi
                while abs_goal.pan > math.pi:
                    abs_goal.pan -= math.pi

                # clamp the adjusted tilt to lie within [-pi/2, pi/2]
                while abs_goal.tilt < -math.pi/2:
                    abs_goal.tilt += math.pi
                while abs_goal.tilt > math.pi/2:
                    abs_goal.tilt -= math.pi

            except Exception as err:
                self.get_logger().error(f"Failed to look up transform between {self.camera_base_link} and {goal_handle.frame_id}: {err}")

        ptz_client = actionlib.SimpleActionClient("move_ptz/position_abs", PtzAction)
        ptz_client.wait_for_server()

        def done_cb(state, result):
            tf_result = PtzRelToResult(result.success)
            if state == actionlib.GoalStatus.SUCCEEDED:
                self.tf_ptz_abs_srv.set_succeeded(tf_result)
            elif state == actionlib.GoalStatus.PREEMPTED:
                self.tf_ptz_abs_srv.set_preempted()
            else:
                self.tf_ptz_abs_srv.set_aborted(tf_result)

        def feedback_cb(fb):
            tf_fb = PtzRelToFeedback(fb.pan_remaining, fb.tilt_remaining, fb.zoom_remaining)
            self.tf_ptz_abs_srv.publish_feedback(tf_fb)

        ptz_client.send_goal(abs_goal,
            feedback_cb = feedback_cb,
            done_cb = done_cb
        )
        ptz_client.wait_for_result()

    def frame_ptz_actionHandler(self, goal_handle):
        """Pan & tilt the camera to point to a specific frame in the TF tree
        """
        abs_goal = PtzGoal()
        abs_goal.zoom = goal_handle.zoom

        try:
            # The the transformation between the camera base link & the reference frame
            tf_buffer = tf2_ros.Buffer(rclpy.duration.Duration(100.0))
            tf_listener = tf2_ros.TransformListener(tf_buffer)
            tf_stamped = tf_buffer.lookup_transform(self.camera_base_link, goal_handle.frame_id, rclpy.time.Time(), rclpy.duration.Duration(5.0))

            # we want to get the pan & tilt needed to point at the frame
            r = math.sqrt(tf_stamped.transform.translation.x**2 + tf_stamped.transform.translation.y**2 + tf_stamped.transform.translation.z**2)
            yaw = math.atan2(tf_stamped.transform.translation.y, tf_stamped.transform.translation.x)
            pitch = -math.asin(tf_stamped.transform.translation.z/r)

            # yaw & pitch are right-handed, but pan & tilt are left-handed, so invert them
            abs_goal.pan = -yaw
            abs_goal.tilt = -pitch

            # clamp the adjusted pan to lie within [-pi, pi]
            while abs_goal.pan < -math.pi:
                abs_goal.pan += math.pi
            while abs_goal.pan > math.pi:
                abs_goal.pan -= math.pi

            # clamp the adjusted tilt to lie within [-pi/2, pi/2]
            while abs_goal.tilt < -math.pi/2:
                abs_goal.tilt += math.pi
            while abs_goal.tilt > math.pi/2:
                abs_goal.tilt -= math.pi

            ptz_client = actionlib.SimpleActionClient("move_ptz/position_abs", PtzAction)
            ptz_client.wait_for_server()

            def done_cb(state, result):
                tf_result = PtzFrameResult(result.success)
                if state == actionlib.GoalStatus.SUCCEEDED:
                    self.frame_ptz_srv.set_succeeded(tf_result)
                elif state == actionlib.GoalStatus.PREEMPTED:
                    self.frame_ptz_srv.set_preempted()
                else:
                    self.frame_ptz_srv.set_aborted(tf_result)

            def feedback_cb(fb):
                tf_fb = PtzFrameFeedback(fb.pan_remaining, fb.tilt_remaining, fb.zoom_remaining)
                self.frame_ptz_srv.publish_feedback(tf_fb)

            ptz_client.send_goal(abs_goal,
                feedback_cb = feedback_cb,
                done_cb = done_cb
            )
            ptz_client.wait_for_result()

        except Exception as err:
            err_msg = f"Failed to look up transform between {self.camera_base_link} and {goal_handle.frame_id}: {err}"
            self.get_logger().error(err_msg)
            result = PtzFrameResult()
            result.success = False
            self.frame_ptz_srv.set_aborted(result, err_msg)


def main(args=None):
    rclpy.init(args=args)
    node = AxisPtzControlNode('axis_ptz_action_server_node')
    executor = MultiThreadedExecutor()
    rclpy.spin(node, executor=executor)
    node.destroy_node()
    rclpy.shutdown()

if __name__=='__main__':
    main()
